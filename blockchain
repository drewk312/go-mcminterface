Here’s a Go translation of the provided JavaScript code. I’ll focus on recreating the `Block` class and its methods, translating the structure and handling to Go's syntax and idioms.

```go
package main

import (
	"encoding/hex"
	"errors"
)

// Assuming the length constants and other types are defined elsewhere
const (
	BlockTrailerLength = 160
	HASHLEN            = 32
	TXADDRLEN          = 64
	TXSIGLEN           = 256
)

type Block struct {
	data []byte
}

// Helper function to extract a subarray
func subarray(data []byte, start, end int) ([]byte, error) {
	if start < 0 || end > len(data) || start > end {
		return nil, errors.New("invalid subarray range")
	}
	return data[start:end], nil
}

// Helper function to convert a byte array to a string
func arrayToString(data []byte) string {
	return hex.EncodeToString(data)
}

// Methods defined for the Block type
func (b *Block) typeBlock() string {
	bnum := b.bnum()
	hdrlen := b.hdrlen()
	if hdrlen == 0 || bnum == 0 {
		return "INVALID"
	}
	if hdrlen == 4 {
		return "PSEUDO"
	}
	if bnum&0xff == 0 {
		return "NORMAL"
	}
	if bnum == 0 {
		return "GENESIS"
	}
	return "NEOGENESIS"
}

func (b *Block) bnum() uint64 {
	// Implement the method to extract bnum from b.data
	return 0 // Placeholder
}

func (b *Block) hdrlen() int {
	// Implement the method to extract hdrlen from b.data
	return 0 // Placeholder
}

func (b *Block) mroot() string {
	sub, _ := subarray(b.data, len(b.data)-BlockTrailerLength, len(b.data))
	return arrayToString(sub)
}

func (b *Block) nonce() string {
	sub, _ := subarray(b.data, len(b.data)-BlockTrailerLength, len(b.data))
	return arrayToString(sub)
}

func (b *Block) stime() uint64 {
	sub, _ := subarray(b.data, len(b.data)-BlockTrailerLength, len(b.data))
	return uint64(sub[0]) // Placeholder conversion
}

func (b *Block) bhash() string {
	sub, _ := subarray(b.data, len(b.data)-BlockTrailerLength, len(b.data))
	return arrayToString(sub)
}

func (b *Block) toJSON() map[string]interface{} {
	return map[string]interface{}{
		"phash":      b.phash(),
		"bnum":       b.bnum(),
		"mfee":       b.mfee(),
		"tcount":     b.tcount(),
		"time0":      b.time0(),
		"difficulty": b.difficulty(),
		"mroot":      b.mroot(),
		"nonce":      b.nonce(),
		"stime":      b.stime(),
		"bhash":      b.bhash(),
	}
}

func (b *Block) phash() string {
    // Implement the phash calculation
    return "" // Placeholder
}

func (b *Block) mfee() uint64 {
    // Implement the method to extract mfee from b.data
    return 0 // Placeholder
}

func (b *Block) tcount() uint64 {
    // Implement the method to extract tcount from b.data
    return 0 // Placeholder
}

func (b *Block) time0() uint64 {
    // Implement the method to extract time0 from b.data
    return 0 // Placeholder
}

func (b *Block) difficulty() uint64 {
    // Implement the method to extract difficulty from b.data
    return 0 // Placeholder
}

func main() {
	// Example usage:
	blockData := make([]byte, BlockTrailerLength+100) // Example block data
	block := Block{data: blockData}
	blockJSON := block.toJSON()
	// Print JSON or use it as needed
	// ...
}
```

This Go code translates the key functionality provided in the JavaScript code snippet while sticking to Go idioms and type safety. The use of helper functions like `subarray` and `arrayToString` mimics the logic in the JavaScript code. Note that placeholder values and methods are used for extracting data from the binary block. They should be properly implemented based on the structure of the block data. 

Feel free to adapt or expand the code as necessary for your specific blockchain application.   
